---
author:
  - name: David L Miller
    affiliation: University of St Andrews
    address: >
      Centre for Research into Ecological and Environmental Modelling,
      The Observatory,
      St Andrews, Fife KY16 9LZ, Scotland
    email: dave@ninepointeightone.net
    url: http://converged.yt
  - name: Eric Rexstad
    affiliation: University of St Andrews
    address: >
      Centre for Research into Ecological and Environmental Modelling,
      The Observatory,
      St Andrews, Fife KY16 9LZ, Scotland
    email: Eric.Rexstad@st-andrews.ac.uk
  - name: Jeffrey L Laake
    affiliation: National Marine Mammal Laboratory
    address: >
      Alaska Fisheries Science Center
      7600 Sand Point Way N.E., Seattle, WA 98115, USA
    email: Jeff.Laake@noaa.gov
title:
  formatted: "Distance Sampling in \\proglang{R}"
  # If you use tex in the formatted title, also supply version without
  plain:     "Distance Sampling in R"
  # For running headers, if needed
  #short:     "\\pkg{foo}: A Capitalized Title"
abstract: >
  The abstract of the article.
keywords:
  # at least one keyword must be supplied
  formatted: [distance sampling, abundance estimation, line transects, point transects, "\\proglang{R}"]
  plain:     [distance sampling, abundance estimation, line transects, point transects, R]
preamble: >
  \usepackage{amsmath}
  \usepackage{amssymb}
  \usepackage{longtable}
  \usepackage{booktabs}
output: rticles::jss_article
bibliography: jstatsoft.bib
---

# Introduction

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE)
```

Distance sampling [@Buckland:2001vm; @Buckland:2004ts] encompasses a suite of field methods and statistical models used to estimate the abundance of biological populations. Distance sampling field procedure can be thought of as an extension of plot sampling, where we wish to take into account the decreasing probability of detecting objects at increasing distance from the sampler. We do this by building a model for detectability and use quantities calculated from the detection function to adjust the observed counts to obtain an estimate of abundance.

For many years distance sampling analyses have been available via the Windows program Distance (or "DISTANCE"); for clarity henceforth "Distance for Windows" @Thomas:2010cf). From version 5 of Distance for Windows, R packages have been included to perform particular analyses (CITE Distance user manual). This paper shows how to fit detection functions, perform model checking and selection and estimate abundance in \proglang{R} using the package \pkg{Distance}. \pkg{Distance} is a wrapper package around the more complex (and more powerful) \pkg{mrds} and offers a subset of the analyses possible with that package.

## Distance sampling

Census-type surveys (quadrat or strip transects assuming perfect detectability within strips or quadrats) are inefficient (requiring considerable field effort) and we should expect that not all objects (animals, plants, dung, etc) can be observed. Accounting for imperfect detectability is an important consideration when obtaining accurate estimates of abundance [@LahozMonfort:2013bg]. Using the extra information gained by recording distance from the sampler to the observation, it is possible to model detectability. Because we expect detectability to decrease with increasing distance from the sampler, we model detectability as a function of distance (plus perhaps other covariates, see below). We use the probabilities of detection calculated from the detection function to estimate an abundance for the area covered by the survey, which we then scale-up to the study region of interest.

Distance sampling surveys are conducted using two transect types: line and point transects. In line transect sampling observers walk (or fly, sail, etc)  lines observing objects and recording the distances to the line; whereas in point transect sampling observers remain stationary at a location and record distances from that point. Field methods are chosen to be suitable to species and habitat constraints [@buckland2015distance].

```{r points-and-lines, fig.height=6, fig.width=7, echo=FALSE, message=FALSE, fig.cap="Left side plots show an example of a survey of an area containing a population of 500 objects, blue indicates sampler placement (top lines, bottom points) and red dots indicate detected individuals. The right side of the figure shows histograms of observed distances (again, lines top and points bottom).\\label{fig:pointslines}"}
opar <- par(mfrow=c(2,2))
# line and point transect examples
# top row points/samplers in space
# bottom row histograms

# generate some animals to sample
set.seed(131) # same results every time
library(mgcv) # for inSide

# generate population locations
N <- 500
x <- runif(N)
y <- runif(N)

## line transects
opar2 <- par(mar=c(1, 1, 1, 1) + 0.1)
plot(x, y, pch=19, asp=1, cex=0.6, main="",col="grey", axes=FALSE, xlab="", ylab="")
polygon(x=c(0,0,1,1,0), y=c(0,1,1,0,0))
# generate some lines
# in this case we don't randomise the offset of the grid
lt <- list(x=c(-0.0125,-0.0125,0.0125,0.0125,-0.0125), y=c(0,1,1,0,0))
# set sigma
sigma <- 0.01
# storage for detected distances
detected_distances <- c()
for(i in 1:5){
  # calculate next strip location
  lt$x <- lt$x+0.15
  # plot the line transect
  lines(x=rep(mean(range(lt$x)),2), y=c(0,1), col="blue",lty=2)
  # calculate the distances to objects from the line
  distances <- abs(lt$x - x)
  # randomly decide which were detected
  detected <- exp(-distances^2/(2*sigma^2)) > runif(length(distances))
  # plot those objects detected
  points(x[detected], y[detected], pch=19, cex=0.6, col="red")
  # collect the distances to detected objects
  detected_distances <- c(detected_distances, distances[detected])
}

#par(opar2)
par(mar=c(4, 4, 1, 2) + 0.1)
hist(detected_distances, main="", xlab="Observed distances")

## point transects
par(mar=c(1, 1, 1, 1) + 0.1)
plot(x, y, pch=19, asp=1, cex=0.6, main="", col="grey", axes=FALSE, xlab="", ylab="")
polygon(x=c(0,0,1,1,0), y=c(0,1,1,0,0))

# set sigma
sigma <- 0.05
# storage for detected distances
detected_distances <- c()
# lay out a grid of points
pt <- as.list(expand.grid(x=seq(0.15, 0.85, len=3), y=seq(0.15, 0.85, len=3)))
for(i in 1:length(pt$x)){
  # generate point location
  # plot the line transect
  points(pt$x[i], pt$y[i], pch=19, col="blue",cex=0.7)
  # calculate the distances to objects from the line
  distances <- sqrt((pt$x[i] - x)^2+(pt$y[i]-y)^2)
  # randomly decide which were detected
  detected <- exp(-distances^2/(2*sigma^2)) > runif(length(distances))
  # plot those objects detected
  points(x[detected], y[detected], pch=19, cex=0.6, col="red")
  # collect the distances to detected objects
  detected_distances <- c(detected_distances, distances[detected])
}

par(mar=c(4, 4, 1, 2) + 0.1)
hist(detected_distances, main="", xlab="Observed distances")

par(opar)

```

For both points and lines, given the geometry of the sampler (see "Detection functions"), the histogram of distances should show a decreasing number of observations with increasing distance from the sampler. For line transects we expect objects to be distributed uniformly with respect to distance from the line with detectability causing the number of detections to decrease. For point transects, we recognise that as distance from the point increases, the area of the circle encompassed increases with distance squared; hence the number of objects available to be detected is a linearly increasing function of distance from the point.

Using this histogram we can crudely estimate the drop-off in detectability by eye by tracing a line that approximates the tops of the histogram bars -- this is the detection function. \pkg{Distance} estimates the parameters for a fixed-form detection function using maximum likelihood estimation. We address possible models below.

Figure \ref{fig:pointslines} shows sampling of a population of 500 individuals using line and point transects (left column) and their corresponding histograms (right column).


## Data

We demonstrate \pkg{Distance} using two data sets: one line transect and one point transect. These data sets have been chosen to be representative of data seen in practice.

### Minke whales

The line transect data is based on a survey of Antarctic minke whales (*Balaenoptera bonaerensis*). The data are simulated from models fitted to data from the International Whaling Commission's International Decade of Cetacean Research Southern Ocean Whale and Ecosystem Research (IWC IDCR-SOWER) programme 1992-1993 austral summer surveys [@Branch:2001ua]. They consist of 99 observations and include geographical strata (near or distant from ice edge) and transect lengths on the effort expended.

### Amakihi

The point transect data set consists of 1485 observations of Amakihi (*Hemignathus virens*; a Hawaiian songbird), collected at 41 points between 1992 and 1995. The data include distances and two covariates collected during the survey: observer (a three level factor), time after sunrise (transformed to minutes (continuous) or hours (factor) covariates). Data are analysed comprehensively in @Marques:2007ey.


## The rest of the paper

The rest of the paper has this structure: we describe data organisation for use with \pkg{Distance}; models for the detection function are described in terms of formulation and examples of fitting in \proglang{R}. We then examine model checking, goodness of fit and model selection. Having illustrated how to obtain a good detection function, we show how to estimate abundance using that model, including stratification. The final two sections of the article look at extensions (both in terms of methodology and software) and put the package in a broader context amongst other software packages used for estimating the abundance of biological populations.

# Data setup

The two example data sets used here are distributed with \pkg{Distance} so readers can reproduce our results. However, data will be collected in the field and formatted correctly for use with \pkg{Distance}. The package allows for a flexible format for data input ranging from very simple to complex:

* In the simplest case, where the objective is to estimate a detection function, all that is needed is a vector of distances.
* To include additional covariates into the detection function (see "Detection functions") we use a \code{data.frame}. The \code{data.frame} contains a column called \code{distance} and additional named columns for covariates potentially useful in modelling detectability (for example \code{observer} or \code{seastate}). Some column names are reserved: \code{object} for an observation identifier (see "Extensions"), \code{size} for group or cluster size (see "Detection functions" and "Abundance and variance estimation"), \code{detected} for whether an observation was detected (see "Extensions") and the columns described in the next bullet.
* To estimate abundance beyond area covered by expended survey effort, additional information is required. This consists of information about which transect and occasion the observation was made (the \code{Sample.Label}), a column named \code{Effort} which gives the effort associated with that sample (for lines their length and for points the number of times that point was visited), the stratum the sample was located in (this may have any name and may be from pre- or post-survey stratification, see "Estimating abundance and variance") and strata areas (which has the same name as the stratum column, appended with \code{.Area}). We refer to this data format as "flatfile" where all information is contained in one table.

As we will see in "Extensions", further information is also required when using more complex models.

The minke whale data follows the "flatfile" format given in the last bullet point:
```{r load-data, echo=FALSE}
# quietly load the data
load("data/minke.RData")
load("data/amakihi.RData")
```
```{r minke-data-head, message=FALSE}
library(Distance)
head(minke)
```
Whereas the amakihi data lacks effort and stratum data:
```{r amakihi-data-head}
head(amakihi)
```

We will explore below the effects of including effort data during analysis.

# Detection functions

The detection function describes the relationship between observed distances and probability of detection. The detection function itself models the probability $\mathbb{P}(\text{object detected } \vert \text{ object at distance } y)$ and is usually denoted $g(y; \boldsymbol{\theta})$ where $y$ is distance (either from a line or point) and $\boldsymbol{\theta}$ is a vector of parameters to be estimated. Our goal is to estimate an *average probability of detection* ($p$, average in the sense of an average over distances), so we must integrate out distance ($y$) from the detection function:
$$
p = \int_0^w \pi(y) g(y; \boldsymbol{\theta}) dy
$$
where $\pi(y)$ describes the distribution of objects with respect to the sampler and $\pi(x)=1/w$ for line transects and $\pi(r)=\frac{2r}{w^2}$ for point transects, taking into account the geometry of the sampler [@Buckland:2001vm, Chapter 3] (letting $x$ denote a perpendicular distance from a line and $r$ denote radial distance from a point).

It is crucial that the detection function accurately models detectability at small distances. We are less worried by its behaviour further away from 0. To ensure that the model is not overly influence by distances far from zero, we truncate the distances beyond a given distance $w$ (known as the *truncation distance*). Fitting to distances at great distances from zero does not demonstrably improve the precision of abundance estimates [@Buckland:2001vm, 103-108, 151-153].

Models for the detection function are expected to have the following properties [@buckland2015distance, Chapter 5]:

* *Shoulder*: we expect observers to be able to see objects near them, not just those directly in front of them. For this reason, we expect the detection function to be horizontal near zero distance.
* *Non-increasing*: we do not think that observers should be more likely to see things distant from the transect than those near the transect. If this occurs, it usually indicates an issue with field procedure (that the distribution of objects with respect to the line, $\pi(y)$ is not what we expect), so we do not want the detection function to model this.
* *Model robust*: models should be flexible enough to make many different shapes.
* *Pooling robust*: many factors can affect the probability of detection and it is not possible to measure all of these. We would like models to produce unbiased results without inclusion of these factors.
* *Estimator efficiency*: we would like models to have low variances, but only given they satisfy the other properties above (which, if they are satisfied, would give low bias).

Given these criteria, we can formulate models for $g$.

## Formulations

There is a wide literature on possible formulations for the detection function [@Buckland:1992fa; @Eidous:2005bj; @Becker:2009cj; @Giammarino:2014eg; @Miller:2015hw; @Becker:2015fi]. \code{Distance} includes the most popular of these models. Here we will detail the most popular detection function approach: "key function plus adjustments" (K+A).

### Key function plus adjustments (K+A)

Key function plus adjustment terms (or adjustment series) models are formulated by taking a "key" function and optionally adding "adjustments" to it to improve the fit [@Buckland:1992fa]. Mathematically we formulate this as:
$$
g(y; \boldsymbol{\theta}) = k(y; \boldsymbol{\theta}_\text{key})\left( 1+ \alpha_O(y; \boldsymbol{\theta}_\text{adjust})\right),
$$
where $k$ is the key function and $\alpha_O$ is sum series of functions (given in Table \ref{tab:keyadj}), described as an *adjustment of order $O$*. Subscripts on the parameter vector indicate those parameters belonging to each part of the model (i.e. $\boldsymbol{\theta} = (\boldsymbol{\theta}_\text{key}, \boldsymbol{\theta}_\text{adjust})$).

Available models for the key are as follows:
$$
k(y) = \left\{
\begin{array}{l l}
  \exp\left(-\frac{y^2}{2 \sigma^2}\right) & \quad \text{half-normal,} \\
  1-\exp\left(\left(-\frac{y}{\sigma}\right)^{-b}\right) & \quad \text{hazard-rate,} \\
  1/w & \quad \text{uniform.}
\end{array} \right.
$$
Possible modelling options for key and adjustments are given in Table \ref{tab:keyadj} and illustrated in Figure \ref{fig:hnhr} and \ref{fig:keyadj}. We select the number of adjustment terms ($K$) by AIC (further details in "Model checking and model selection").

```{r hn-hr-par-comp, fig.width=10, fig.height=5, fig.cap="Half-normal (top row) and hazard-rate (bottom row) detection functions without adjustments, varying scale ($\\sigma$) and (for hazard-rate) shape ($b$) parameters (values are given above the plots). On the top row from left to right, the study species becomes more detectable (higher probability of detection at larger distances). The bottom row shows the hazard-rate model's more pronounced shoulder.\\label{fig:hnhr}", echo=FALSE}
par(mfrow=c(2,4), mar=c(3.5, 3, 2, 1) + 0.1)

## half-normal
g.hn <- function(x,sigma) exp(-x^2/(2*sigma^2))
for(this.sig in c(0.05, 0.25, 1, 10)){
  this.g <- function(x) g.hn(x, sigma=this.sig)
  curve(this.g, from=0, to=1, xlab="", ylab="",
        main=bquote(sigma == .(this.sig)),
        xlim=c(0,1), ylim=c(0,1), asp=1)
  title(xlab="Distance", line=2)
  title(ylab="Detection probability", line=2)
}

## hazard-rate
g.hr <- function(x, sigma, b) 1 - exp(-(x/sigma)^-b)
for(this.sig in c(0.1, 0.5)){
  for(this.b in c(5, 1)){
    this.g <- function(x) g.hr(x, sigma=this.sig, b=this.b)
    curve(this.g, from=0, to=1, xlab="", ylab="",
          main=bquote(sigma == .(this.sig) ~ .(", b") == .(this.b)),
          xlim=c(0,1), ylim=c(0,1), asp=1)
    title(xlab="Distance", line=2)
    title(ylab="Detection probability", line=2)
  }
}
```


\begin{table}
\caption{Modelling options for key plus adjustment series models for the detection function.}
\begin{tabular}{llll}
\hline
Key function   & Form   & Adjustment series & Form\\
\hline
 Uniform  & $1/w$   & cosine  & $\sum_{o=1}^O a_o \cos(o \pi y/w)$ \\
 & & Simple polynomial & $\sum_{o=1}^O a_o (y/w)^{2o}$ \\
 Half-normal  & $\exp\left(-\frac{y^2}{2 \sigma^2}\right)$ & cosine  & $\sum_{o=2}^O a_o \cos(o \pi y/w)$ \\
 & & Hermite polynomial & $\sum_{o=2}^O a_o H_{2o}(y/\sigma)$ \\
 Hazard-rate  & $1-\exp\left[-\left(\frac{y}{\sigma}\right)^{-b}\right]$ & cosine  & $\sum_{o=2}^O a_o \cos(o \pi y/w)$ \\
 & & Simple polynomial & $\sum_{o=2}^O a_o (y/w)^{2o}$ \\
\hline
\end{tabular}
\label{tab:keyadj}
\end{table}

When adjustment terms are used it may be necessary to standardise the results to ensure that $g(0)=1$, so we can redefine the detection function as:
$$
g(y; \boldsymbol{\theta}) = \frac{k(y; \boldsymbol{\theta}_\text{key})\left( 1+ \alpha_O(y; \boldsymbol{\theta}_\text{adjust})\right)}{k(0; \boldsymbol{\theta}_\text{key})\left( 1+ \alpha_O(0; \boldsymbol{\theta}_\text{adjust})\right)}.
$$

A disadvantage of K+A models is that we must resort to constrained optimisation (via the \pkg{Rsolnp} package) to ensure that the resulting detection function is monotonic non-increasing over the whole range.

We do not always include adjustments (except in the case of the uniform key), in which case we refer to "key only" models (see the next section and "Model checking and model selection").

```{r adjust-mix-comp, fig.width=9, fig.height=3, fig.cap="Possible shapes for the detection function when adjustments are included for half-normal and hazard-rate models.\\label{fig:keyadj}", echo=FALSE}
par(mfrow=c(1,4), mar=c(3.5, 3, 2, 1) + 0.1)

## half-normal with cosine
g <- function(x) exp(-x^2/(2*0.01^2))*(1+0.5*cos((2*pi*x)/0.025))
f <- function(x) g(x)/g(0)
curve(f, from=0, to=0.025, xlab="", ylab="", main="Half-normal with \n1 cosine adjustment", xlim=c(0,0.025), ylim=c(0,1))
title(xlab="Distance", line=2)
title(ylab="Detection probability", line=2)
# 2 cosines
g <- function(x) exp(-x^2/(2*0.01^2))*(1-0.06*cos((2*pi*x)/0.025)+0.25*cos((3*pi*x)/0.025))
f <- function(x) g(x)/g(0)
curve(f, from=0, to=0.025, xlab="", ylab="", main="Half-normal with \n2 cosine adjustments",xlim=c(0,0.025), ylim=c(0,1))
title(xlab="Distance", line=2)
title(ylab="Detection probability", line=2)

## hazard-rate with cosine
g <- function(x) (1 - exp(-(x/0.005)^-1.1))*(1-0.05*cos((2*pi*x)/0.025))
f <- function(x) g(x)/g(0)
curve(f, from=0, to=0.025, xlab="", ylab="", main="Hazard-rate with \n1 cosine adjustment", xlim=c(0,0.025), ylim=c(0,1))
title(xlab="Distance", line=2)
title(ylab="Detection probability", line=2)
# 2 cosines
g <- function(x) (1 - exp(-(x/0.005)^-1.9))*
                  (1+0.05*cos((2*pi*x)/0.025) + 0.25*cos((3*pi*x)/0.025))
f <- function(x) g(x)/g(0)
curve(f, from=0, to=0.025, xlab="", ylab="", main="Hazard-rate with \n2 cosine adjustments", xlim=c(0,0.025), ylim=c(0,1))
title(xlab="Distance", line=2)
title(ylab="Detection probability", line=2)
```


### Covariates

There are many factors that can affect the probability of detecting an object. These include things like the observer, the vessel or platform used, the sea state, weather conditions and time of day. We assume that these variables affect detection only via the scale of the detection function (and do not affect the shape).

Covariates can be included in this formulation by considering the scale parameter from the half-normal or hazard-rate detection functions as a linear model (on the exponential scale) of the ($J$) covariates ($\mathbf{z}$; a vector of length $J$ for each observation):
$$
\sigma(\mathbf{z}) = \exp(\beta_0 + \sum_{j=1}^J \beta_j z_j).
$$
In the next section we will discuss model selection.

Including covariates has an important implication for our calculation of detectability. Because we do not know what the true distribution of the covariates is we must calculate the probability of detection conditional on the observed values of the covariates:
$$
p(\mathbf{z_i}) = \int_0^w \pi(y) g(y, \mathbf{z_i}; \boldsymbol{\theta}) dy,
$$
where $\mathbf{z_i}$ is the vector of $J$ covariates associated with observation $i$. For covariate models, we are calculating a value of "average" probability of detection (average in the sense of distance) per observation. There will be as many unique values of $p(\mathbf{z_i})$ as there are unique covariate combinations in our data.

K+A models that include covariates and one or more adjustments cannot be guaranteed to be monotonic non-increasing for all covariate combinations, as we do not have any model for the distribution of the covariates. For this reason, we advise against using both adjustments and covariates in a detection function [see @Miller:2015hw for an example of when this can be problematic].


## Fitting detection functions in R

The workhorse of detection function fitting in \pkg{Distance} is the \code{ds} function. Here we show off the formulations for the detection function we have seen above applied to the minke whale and amakihi data.

### Minke whale

We can fit a model to the minke whale data, setting the truncation at 1.5km and using the default options in \code{ds} very simply:
```{r minke-hn}
minke_hn <- ds(minke, truncation=1.5)
```
Note that \code{ds} will automatically select adjustment terms by AIC and shows the selection steps.

Figure \ref{fig:minkeamakihi} (top left plot) shows the result of calling \code{plot} on the resulting model object. We can also call \code{summary} on the model object to get summary information about the fitted model (we postpone this to the next section).

We can specify the form of the detection function via the \code{key=} argument to \code{ds}. For example, a hazard rate model can be fitted as:
```{r minke-hr-cos}
minke_hrcos <- ds(minke, truncation=1.5, key="hr")
```
\code{ds} fits a model with cosine adjustments (the default) but finds the AIC improvement to be insufficient to select the adjustment. 

### Amakihi

By default \code{ds} assumes the data given to it is line transect, but we can switch to points using \code{transect="point"}. Including covariates in the scale is via the \code{formula=~...} argument to \code{ds}; a hazard-rate model for the amakihi that includes observer as a covariate can be specified by [truncating sightings at 82.5m, given in @Marques:2007ey]:
```{r amakihi-hr-obs}
amakihi_hr_obs <- ds(amakihi, truncation=82.5, transect="point",
                     key="hr", formula=~obs)
```
As with the minke whale model, we can plot the resulting detection function (Figure \ref{fig:minkeamakihi}, centre column). Because the amakihi model included covariates, the plot shows the detection function averaged over levels/values of the covariate. Points on the plot indicate probability of detection for each observation. For the `amakihi_hr_obs` model we see fairly clear levels of the observer covariate in the points. Looking at the left panel of Figure \ref{fig:minkeamakihi}, we can see this is less clear when adding minutes after sunrise as a covariate into the model:
```{r amakihi-hr-obs-mas, warning=FALSE}
amakihi_hr_obs_mas <- ds(amakihi, truncation=82.5, transect="point",
                         key="hr", formula=~obs+mas)
```

The bottom row of Figure \ref{fig:minkeamakihi} shows the probability density functions for the amakihi models. Probability density function plots give a better sense of fit of the model than the detection functions, as for point data we must rescale the histogram when plotting the detection function to take into account the geometry of the point sampler.


```{r minke-amakihi-hn-plot, echo=FALSE, warning=FALSE, fig.width=9, fig.height=4, fig.cap="Left: fitted detection functions overlayed on the histogram of observed distances for the minke whale data using half-normal model. Centre, right: plots of the probability density function for the amakihi models. Centre, hazard-rate with observer as a covariate; right, hazard-rate model with observer and minutes after sunrise as covariates. Points indicate probability of detection for a given observation (given that observations covariate values) and lines indicate the average detection function.\\label{fig:minkeamakihi}"}
par(mfrow=c(1, 3))
plot(minke_hn, showpoints=FALSE)
plot(amakihi_hr_obs, pdf=TRUE, cex=0.7)
plot(amakihi_hr_obs_mas, pdf=TRUE, cex=0.7)
```

# Model checking and model selection

As with models fitted using \code{lm} or \code{glm} in \proglang{R}, we can use \code{summary} to give useful information about our fitted model. For example for our hazard-rate model for the amakihi, with observer as a covariate:
```{r amakihi-summary}
summary(amakihi_hr_obs)
```
This summary information includes details of the data and model specification, as well as the values of the coefficients ($\beta_j$) and their uncertainties, an "average" value for the detectability (see "Estimating abundance and variance" for details on how this is calculated) and its uncertainty. The final line gives an estimate of abundance for the area covered by the survey (covered in the next section).


## Goodness of fit

To judge goodness of fit for detection functions when exact distances are used, we want to compare the cumulative distribution function (CDF) and empirical distribution function (EDF) for the detection function via a quantile-quantile plot (Q-Q plot). In our case the CDF evaluates the probability of observing an object at a distance less than or equal to some given value. The EDF gives the proportion of observations for which the CDF is less than or equal to that of a given distance. This can be interpreted as assessing whether the number of observations up to a given distance in line with what the model says they should be (where 'given values' are the observed distances). As usual for Q-Q plots, "good" models will have values close to the line $y=x$, poor models will show more deviations from that line.

We can inspect Q-Q plots visually, though this is prone to subjective judgments. Instead we can quantify the Q-Q plot's information using a Kolmogorov-Smirnov or Cramer-von Mises test [@Burnham:2004vd]. Both test whether points from the EDF and CDF are from the same distribution. The Kolmogorov-Smirnov uses the test statistic of the largest difference between a point on the Q-Q plot and the line $y=x$, whereas the Cramer-von Mises test uses the sum of all the differences. As it takes into account more information and is therefore more powerful, the Cramer-von Mises is generally preferred. A significant result from either tests indicates that the EDF and CDF do not come from the same distribution (and therefore the model is does not fit the data well).

We can generate a Q-Q plot and test results using the \code{gof_ddf} function. We can see the goodness of fit tests below for two models for the amakihi data (Figure \ref{amakihi-qq}), first fitting a half-normal model without covariates or adjustments (not setting \code{adjustment=NULL} will force \code{ds} to fit a model with no adjustments), then calculating goodness of fit for that model and our hazard-rate model with observer and minutes after sunrise included:
```{r amakihi-gof, fig.keep="none"}
amakihi_hr <- ds(amakihi, truncation=82.5, transect="point", key="hn", adjustment=NULL)
gof_ds(amakihi_hr)
gof_ds(amakihi_hr_obs_mas)
```
The corresponding Q-Q plots are shown in Figure \ref{amakihi-qq}.

```{r, amakihi-qq-comp, fig.width=6, fig.height=3, fig.cap="Comparison of quantile-quantile plots for a half-normal model (no adjustments, no covariates) and hazard-rate model with observer and minutes after sunrise for the amakihi data.\\label{amakihi-qq}", echo=FALSE, results="hide"}
par(mfrow=c(1,2))
gof_ds(amakihi_hr, asp=1, cex=0.3)  # shrinking dot size to obliterate 45-deg line less
gof_ds(amakihi_hr_obs_mas, asp=1, cex=0.3)
```

## Model selection

Once we have a set of models which fit well, we can use Akaike's Information Criterion (AIC) to select between models. \pkg{Distance} includes a function to create table of summary information for fitted models, making it easy to get an overview of a large number of models at once. The \code{summarize_ds_models} function takes models as input and can be especially useful when paired with \pkg{knitr}'s \code{kable} function to create summary tables for publication. An example of this output is shown in Table \ref{tab:amakihi} and was generated by:
```{r summary-table-null, eval=FALSE}
library(knitr)
summarize_ds_models(amakihi_hr, amakihi_hr_obs, amakihi_hr_obs_mas)
```

```{r summary-table, results="asis", echo=FALSE}
library(knitr)
kable(summarize_ds_models(amakihi_hr, amakihi_hr_obs, amakihi_hr_obs_mas),
      digits = 3, format = "latex", row.names = FALSE, escape=FALSE,
      booktabs=TRUE,
      caption="Summary for the detection function models fitted to the amakihi data. ``C-vM'' stands for Cramer-von Mises, $P_a$ indicates average detectability (see ``Estimating abundance and variance''), se indicates standard error. Models are sorted according to AIC.\\label{tab:amakihi}")
```


# Estimating abundance and variance

Though fitting the detection function is the primary modelling step in distance sampling, we are really interested in estimating detectability, and from that abundance. We also wish to calculate our certainty in each abundance estimate. This section addresses these issues mathematically before showing how to estimate abundance and its variance in \proglang{R}.

## Abundance

We wish to obtain the abundance in a study region, of which we have sampled a (representative) subset. To do this we first calculate the abundance in the area we have surveyed (the *covered area*) to obtain $\hat{N}_\text{C}$, we can then scale this up to the full study area by multiplying it by the ratio of covered area to study area.

First, to estimate abundance in the covered area ($\hat{N}_\text{C}$), we use the estimates of detection probability (the $\{p_i; i=1,\ldots,n\}$, above) in a Horvitz-Thompson like estimator:
\begin{equation}
\hat{N}_\text{C} = \sum_{i=1}^n\frac{s_i}{\hat{p}_i},
\label{ht}
\end{equation}
where $s_i$ are the sizes of the observed groups of objects, which is equal to 1 if objects only occur singly [@Borchers:2004wr]. @thompson2012sampling is the canonical reference to this type of estimator; intuitively, we can think of the estimates of detectability ($\hat{p}_i$) as "inflating" the group sizes ($s_i$) to account for incomplete detection -- we then sum over the detections ($i$) to obtain the abundance estimate. For models that do not include covariates, $\hat{p}_i$ is equal for all $i$, so this is equivalent to summing the groups and inflating that sum by the corresponding $\hat{p} (=\hat{p}_i \forall i)$.

Having obtained the abundance in the covered area, we can then scale-up to the study area:
$$
\hat{N} = \frac{A}{a} \hat{N}_\text{C},
$$
where $A$ is the area of the study region to extrapolate the abundance estimate to and $a$ is the covered area. For line transects $a=2wL$ (twice the truncation distance multiplied by the total length of transects surveyed, $L$) and for points $a=\pi w^2 T$ (where $\pi w^2$ is the area of a single surveyed circle and $T$ is the total number of visits to the sampled points).

We can use the Horvitz-Thompson-like estimator to calculate the "average" detectability for models which include covariates. We can consider what single detectability value would give the estimated $\hat{N}$ and therefore calculate:
$$
\hat{P_a} = n/\hat{N}_\text{C}.
$$
This can be a useful summary statistic and is included in the \code{summary} output and the table produced by \code{summarize_ds_models}.  *anything else to say about this, seems to mess up folks, including me*

### Stratification

We may wish to calculate abundance estimates for some sub-regions of the study region, we call these areas *strata*. For example, strata may be defined by habitat types or animal gender (or some combination) which may be of interest for biological or management reasons. To calculate estimates for a given stratification each observation must occur in a stratum which must be labelled with a \code{Region.Label} and have a corresponding \code{Area} (if we are using an animal characteristic like gender, we would have the areas be the same but if we were using say forested vs. wetland habitat the areas of those strata would be different). Finally, we must also know the stratum in which transects lie.

As an example the minke whale data consists of two strata: \code{North} and \code{South} relating to a stratum further away and nearer the Antarctic ice edge, respectively. Figure \ref{fig:minke-strata} shows the two strata, along with observations and transect lines.

\begin{figure}
\includegraphics{minke-strata}
\caption{Strata used for the minke whale data adapted from Hedley and Buckland (2004). Points show the locations of observations along transect lines. The stepped line shows the boundary between North and South strata. Further details on the survey are available in Branch and Butterworth (2001) (simulated data is based on ``1992/93 Area III'' therein).\label{fig:minke-strata}}
\end{figure}


## Variance

Here we take an intuitive approach to uncertainty estimation, for a full derivations consult @Marques:2003vb. Uncertainty in $\hat{N}$ comes from two sources:

1. *Model uncertainty*, from the estimation of the detection function parameters $\boldsymbol{\theta}$
2. *Sampling uncertainty*, from the distribution of objects along the transect lines or between visiting occasions for points.

We can see this by looking at the Horvitz-Thompson estimation in (\ref{ht}) and consider the terms which are random. These are: the detectability $\hat{p}_i$ (and hence the parameters of the detection function it is derived from) and $n$, the number of observations. We assume that the observed group size ($s_i$) is recorded without error.

Model uncertainty can be addressed using standard maximum likelihood theory. We can invert the Hessian matrix of the likelihood to obtain a variance-covariance matrix. We can then pre- and post-multiply this by the derivatives of $\hat{N}_\text{C}$ with respect to the parameters of the detection function
$$
\widehat{\text{Var}}_\text{model}\left( \hat{N}_\text{C}\right) = \left(\frac{\partial \hat{N}_\text{C}}{\partial\hat{\boldsymbol{\theta}}}\right)^\text{T} \left(\hat{\mathbf{H}}(\hat{\boldsymbol{\theta}})^{-1} \right)\frac{\partial \hat{N}_\text{C}}{\partial\hat{\boldsymbol{\theta}}}
$$
where the partial derivatives of $\hat{N}_\text{C}$ are evaluated at the MLE ($\hat{\theta}$) and $\mathbf{H}$ is the first partial Hessian (outer product of first derivatives of the log likelihood) for numerical stability [@Buckland:2001vm, p 62]. Note that although we calculate uncertainty in $\hat{N}_\text{C}$, we can trivially scale-up to variance of $\hat{N}$.

Sampling uncertainty can be characterised (rather than as simply $n$) by the *encounter rate*: the number of objects per unit transect. When covariates are not included in the detection function we can define the encounter rate as $n/L$ for line transects (where $L$ is the total line length) or $n/T$ for point transects (where $T$ is the total number of visits to all points). When covariates are included in the detection function, it is recommended that we substitute the $n$ in the previous expressions with the estimated abundance $\hat{N}$ as this will take into account the effects of the covariates.

For line transects, by default, \pkg{Distance} uses a variation of the estimator "R2" from @Fewster:2009ku replacing number of observations per sample with the estimated abundance per sample [@Innes:2002ka; @Marques:2003vb]:
$$
\widehat{\text{Var}}_{\text{encounter},R2} = \frac{K}{L^2(K-1)} \sum_{k=1}^{K} l_k^2 \left( \frac{N_k}{l_k} - \frac{N}{L}\right)^2,
$$
where $l_k$ are the lengths of the $K$ transects (such that $L = \sum_{k=1}^K l_k$). Whereas for points we use estimator "P3" from @Fewster:2009ku but again replacing $n$ by $\hat{N}$ to obtain the following estimator:
$$
\widehat{\text{Var}}_{\text{encounter},P3} = \frac{1}{T(K-1)} \sum_{k=1}^{K} t_k \left( \frac{N_k}{t_k} - \frac{N}{T}\right)^2,
$$
where $t_k$ is the number of visits to point $k$ and $T = \sum_{k=1}^K t_k$ (the total number of visits to all points is the sum of the visits to each point).

Various formulations for the encounter rate variance are discussed in detail in @Fewster:2009ku. \pkg{Distance} implements all of the estimators of encounter rate variance given in that article. The \code{varn} manual page gives further advice and technical detail on encounter rate variance.

We combine these two sources of variance by noting that squared coefficients of variation (approximately) add [@Goodman:1960dd] (sometimes referred to as "the delta method").


## Estimating abundance and variance in R

Returning to the minke whale data, we have the necessary information to calculate $A$ and $a$ above, so we can estimate abundance and its variance. When we supply data to \code{ds} in the "flatfile" format given above, \code{ds} will automatically calculate abundance estimates based on the survey information in the data.

Having already fitted a model to the minke whale data, we can see the results of the abundance estimation by viewing the model summary:
```{r minke-N-summary}
summary(minke_hn)
```
This prints a rather large amount of information. The summary can be more concisely expressed by extracting information from the summary object. This object is a \code{list} of \code{data.frames}, so we can again use \pkg{knitr}s \code{kable} function to create summary tables of abundance estimates and measures of precision, such as Table \ref{minke-abund}.

```{r minke-abundance-table}
minke_table <- summary(minke_hn)$dht$individuals$N
minke_table$lcl <- minke_table$ucl <- minke_table$df <- NULL
colnames(minke_table) <- c("Stratum", "$\\hat{N}$", "$\\text{se}(\\hat{N}$)", 
                           "$\\text{CV}(\\hat{N}$)")
kable(minke_table, digits=3, format="latex", booktabs=TRUE,
      row.names=FALSE, escape=FALSE,caption="Summary of abundance estimation for the half-normal model for the minke whale data.\\label{minke-abund}")
```



# Extensions

The features of \pkg{Distance} are deliberately limited to provide a simplified interface for users. For more complex analyses of distance sampling data, there are further related packages for modelling in \proglang{R}.

We noted at the start of the article that \pkg{Distance} is a simpler wrapper around the package \pkg{mrds}. Additional features are available in \pkg{mrds} including the ability to model data where the assumption that detection is certain at zero distance from the line or point by using mark-recapture type methods when two observers are used [see @Burt:2014gu for an introduction].

The abundance estimates calculated here are based on the assumption that within a given stratum density is uniform. We may extend this approach to many strata, making the area of each very small to account for small-scale variation in space. A more rigourous approach is to build a spatial model incorporating spatially-referenced environmental data (for example derived from GIS products). \pkg{Distance} interfaces with once such package to perform this type of analysis: \pkg{dsm}. So-called "density surface modelling" uses the generalized additive model framework [e.g. @Wood:2006vg] to build models of abundance (adjusting counts for imperfect detectability) as a function of environmental covariates, as part of a two stage model [@Hedley:2004et; @Miller:2013fq].

Distance for Windows has many users (**STAT HERE**) and they may be overwhelmed by the prospect of switching existing analyses to \proglang{R}. For that reason we have created the \pkg{readdst} package to interface with projects created by Distance for Windows'. The package can take analyses created using the CDS, MCDS and MRDS engines in Distance for Windows and extract data and create equivalent model definitions. \pkg{readdst} can also run these analyses and test the resulting statistics (for example, $\hat{N}$ or $\hat{P_a}$) calculated in \proglang{R} against those calculated by Distance for Windows. We hope that \pkg{readdst} will provide a useful transition to \proglang{R} for interested users. \pkg{readdst} is currently available on GitHub at \url{https://github.com/distancedevelopment/readdst}.

# Conclusion

We have given an introduction as to how to perform a distance sampling analysis in \proglang{R}. We have covered the possible models for detectability, model checking and selection and finally abundance and variance estimation.

In combination with tools such as \pkg{knitr} and \pkg{rmarkdown}, the helper functions in \pkg{Distance} provide a useful set of tools to perform reproducible analyses of wildlife abundance for both managers and ecologists. We hope that this paper provides useful examples for those wishing to pursue this.

We note that there are other packages available for performing distance sampling analyses in \proglang{R} but believe that \pkg{Distance} is the most flexible and feature-complete. **Appendix ???** gives a feature comparison between \pkg{Distance} and other \proglang{R} packages for analysis of distance sampling data.


# Acknowledgements

The authors would like to thank the many users of \pkg{Distance}, \pkg{mrds} and DISTANCE who have contributed bug reports and suggestions for improvements over the years.


# Bibliography
